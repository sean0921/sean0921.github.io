<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sean&#39;s Blog</title>
  
  <subtitle>less is more, old is new.</subtitle>
  <link href="https://blog.clam.ml/atom.xml" rel="self"/>
  
  <link href="https://blog.clam.ml/"/>
  <updated>2021-07-25T11:59:20.003Z</updated>
  <id>https://blog.clam.ml/</id>
  
  <author>
    <name>Sean Ho</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 SELinux 環境下建立發行版鏡像站需要處理的權限問題</title>
    <link href="https://blog.clam.ml/2021/07/25/rsync-tmp-file-under-selinux/"/>
    <id>https://blog.clam.ml/2021/07/25/rsync-tmp-file-under-selinux/</id>
    <published>2021-07-25T10:34:20.000Z</published>
    <updated>2021-07-25T11:59:20.003Z</updated>
    
    <content type="html"><![CDATA[<p>SELinux 是讓 Linux 系統管理者又愛又恨的安全性模組之一，它可以保護我們避免自己或他人不恰當的資源誤用，但更多時候我們則是被它複雜的權限設定所困惑，進而將其設定為 Permissive 甚至是 Disabled 來逃避現實。這篇筆記主要描述如何從 rsync 運作原理，來理解在 SELinux 啟用的情況下，如何正確設定 rsync 暫存區路徑參數與暫存區權限，節省往後摸索的時間。</p><span id="more"></span><h2 id="會用到的-SELinux-觀念">會用到的 SELinux 觀念</h2><p>從鳥哥的中文文件<sub><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php#selinux">1</a></sub> 以及 Red Hat 的官方文件<sub><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/index">2</a></sub> 我們可以大致理解 SELinux 主要想管理重點包含「程序是否能正確讀取『對應』的檔案資源」。</p><p>以使用 <a href="https://zh.wikipedia.org/wiki/Nginx">nginx</a> 架設單純的靜態網頁伺服器為例，我們只預期外部使用者 <a href="https://zh.wikipedia.org/wiki/Nginx">nginx</a> 只會存取到: <code>/var/www/html/</code> 或是 <code>/usr/share/nginx/html</code> 的內容，其他非經管理者允許，不小心或刻意讀取到其他路徑下的檔案內容的行為可能都是「邪魔歪道」。</p><p>因此我們會發現利用 <code>ls -Z</code> 列出類似路徑下的檔案參數內容，多會顯示帶有 <code>httpd_sys_content_t</code> 這個標籤，表示這些檔案可以被特定的 http 服務存取，例如 Nginx 或 Apache。</p><p>照這樣來看，如果想要透過 http server 把檔案分享給別人，讓其他路徑下的檔案也能被 http server 存取的方法就是透過 selinux 的管理指令: <code>semanage</code>，將該路徑底下的預設檔案標籤也設定為 <code>httpd_sys_content_t</code></p><p>如果我們想讓檔案能透過其他的公開服務來存取 (ftp, rsync…)，我們還可以把標籤設定成 <code>public_content_t</code>。</p><p>這大概就是我們設定 SELinux 相關內容前，大概要理解的觀念</p><h2 id="會用到的-rsync-觀念">會用到的 rsync 觀念</h2><p>把 rsync 用到的觀念講得最簡明扼要的文件大概就是它自己的官方文件了<sub><a href="https://rsync.samba.org/how-rsync-works.html">3</a></sub></p><p>文件把該 rsync 套件會用到的角色(或程序)分成: client, server, daemon, remote shell, sender, receiver, generator</p><p>以我們想要同步上游 rsync 鏡像站為例，我們是 client，他們是 server，他們同時也有 daemon 的角色(持續地在背景跑 <code>rsyncd</code>)，也因此我們不會用到 remote shell，也就是不會透過 <a href="https://zh.wikipedia.org/wiki/Secure_Shell"><code>ssh</code></a>, <a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E5%A4%96%E5%A3%B3"><code>rsh</code></a>… 等傳輸協定來存取他們的 rsync 服務，而是使用 rsync 自己的協定。他們接受我們要求傳檔案給我們，我們接收檔案，所以 sender 會跑在他們那邊，我們是則會跑 receiver，並在接收到檔案列表後 fork 出 generator 和 receiver，分別進行檔案檢查與接收檔案的工作。</p><p>其中我比較在意的部分在 The Receiver 那邊提到的:</p><blockquote><p>The file’s checksum is generated as the temp-file is built. At the end of the file, <em><strong>this checksum is compared with the file checksum from the sender. If the file checksums do not match the temp-file is deleted.</strong></em><br>…<br>After the temp-file has been completed, its ownership and permissions and modification time are set. It is then <em><strong>renamed to replace the basis file</strong></em>.</p></blockquote><p>以及 <code>rsync(1)</code> man page<sub><a href="https://man7.org/linux/man-pages/man1/rsync.1.html">4</a></sub> 提到的:</p><blockquote><p>This (<code>--checksum</code>) changes the way rsync checks if the files have been changed and are in need of  a  transfer.   Without  this  option, rsync  uses a  “quick check” that (by default) checks if each <em><strong>file’s size</strong></em> and <em><strong>time of last modification</strong></em> match between the sender and receiver.</p></blockquote><p>也就是說</p><ol><li>如果有啟用 <code>--checksum</code>，在確認 checksum (聽說較新版本 rsync 是用 MD5) 沒問題後，temp file 就會從 <strong>暫存路徑</strong> <em>移過去</em> 取代原始檔案。</li><li>如果沒有啟用 checksum 機制，rsync 會使用「快速檢查行為」(“quick check” behavior)，確認最後修改時間和檔案大小沒問題後，temp file 就會從 <strong>暫存路徑</strong> <em>移過去</em> 取代原始檔案。</li></ol><h2 id="實例解說-在-SELinux-啟用的系統上鏡像-Arch-Linux-套件庫">實例解說: 在 SELinux 啟用的系統上鏡像 Arch Linux 套件庫</h2><p>Arch Linux 是一個相當新穎、簡潔的 <strong>x86_64</strong> 發行版，注意這邊也因為它官方只支援 x86_64 這個架構，因此實際把它官方套件庫的全部檔案抓下來，會發現不含 iso 檔大概只有 70 GiB 不到 ( Ubuntu 官方套件庫不含 iso 檔大概要佔用將近 1.5T 的容量)，因此順便鼓勵有需要的團體有興趣可以自行找可靠的 rsync server 來建立自己的 local mirror。</p><p>回到問題，使用 Arch Linux 官方附的建議腳本<sub><a href="https://gitlab.archlinux.org/archlinux/infrastructure/-/blob/master/roles/syncrepo/files/syncrepo-template.sh">5</a></sub> 來同步上游 rsync mirror 的套件庫，並把每個留白的參數都根據自己需求填入資訊，會發生什麼事情呢?</p><p>首先，假設我們要存放 mirror 內容的路徑是 <code>/mnt/mirror</code>，我們仍先把要共享 mirror 檔案內容的目錄及其下所有檔案的標籤都設爲 <code>public_content_t</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -a -t public_content_t &quot;/mnt/mirror(/.*)?&quot;</span><br><span class="line">restorecon -Rv /mnt/mirror</span><br></pre></td></tr></table></figure><p>接著再來執行我們修改過後的同步腳本，然後回去 <code>ls -Z</code> 看看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unconfined_u:object_r:unlabeled_t:s0 community</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 community-staging</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 community-testing</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 core</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 extra</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 gnome-unstable</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 images</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 kde-unstable</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastsync</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastupdate</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 multilib</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 multilib-staging</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 multilib-testing</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 pool</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 staging</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 testing</span><br></pre></td></tr></table></figure><p>咦? 我們沒看錯吧? 於是我們再次 <code>restorecon -Rv /mnt/mirror</code> 後，等待下次更新:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unconfined_u:object_r:public_content_t:s0 community</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 core</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 extra</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 gnome-unstable</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 images</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 kde-unstable</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastsync</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastupdate</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 pool</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 testing</span><br></pre></td></tr></table></figure><p>現在變成有被更新的檔案都會被 unlabeled 了，這難道是廠商的疏失嗎?</p><p>後來經歷一連串的測試之後，終於確定了問題出在 <code>--temp-file</code> 的這個參數，假設我們藉由該參數設定 rsync 暫存路徑為 <code>/mnt/mirror_tmp</code>，接下來我們來進行一個小實驗，任意設定該路徑的 selinux 標籤，改成對 rsync client 沒任何用途的 <code>rsync_tmp_t</code>，並把 <code>/mnt/mirror</code> 的標籤回復後，等待下次進行同步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unconfined_u:object_r:public_content_t:s0 community</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 core</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 extra</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 gnome-unstable</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 images</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 kde-unstable</span><br><span class="line">unconfined_u:object_r:rsync_tmp_t:s0 lastsync</span><br><span class="line">unconfined_u:object_r:rsync_tmp_t:s0 lastupdate</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 pool</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 testing</span><br></pre></td></tr></table></figure><p>此時有被更新過檔案的 selinux 標籤就變成了 <code>rsync_tmp_t</code> 了</p><h3 id="小結">小結</h3><p>於是我們可以確定：</p><p>如果給 rsync 用的暫存目錄 ( <code>--temp-dir</code> ) 放在 selinux context 設定路徑以外的地方，就會使得 rsync 同步完後的 context 變成預期外的內容，進而造成 selinux 的權限錯誤。</p><h3 id="解決方案">解決方案</h3><ol><li>把 temp dir 的 context 設定成和同步目的地一樣的內容</li><li>不要設定 <code>--temp-dir</code> 參數 (這樣暫存檔的位置就會同步目的地一樣的目錄底下)</li></ol><h2 id="總結">總結</h2><p>雖然 SELinux 對於系統管理者在資源的運用上給予了相當多綁手綁腳的限制，但釐清相關運作流程的觀念與細節之後，就可以讓 SELinux 成為使得 Linux 系統服務安全的重要夥伴。這次在 rsync 同步雖然也踩到這個一開始令人困惑的問題，但同樣也藉此進一步地理解了 rsync 相關運作流程和 SELinux 觀念，給予了我們不小啟發。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SELinux 是讓 Linux 系統管理者又愛又恨的安全性模組之一，它可以保護我們避免自己或他人不恰當的資源誤用，但更多時候我們則是被它複雜的權限設定所困惑，進而將其設定為 Permissive 甚至是 Disabled 來逃避現實。這篇筆記主要描述如何從 rsync 運作原理，來理解在 SELinux 啟用的情況下，如何正確設定 rsync 暫存區路徑參數與暫存區權限，節省往後摸索的時間。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://blog.clam.ml/tags/linux/"/>
    
    <category term="sysadmin" scheme="https://blog.clam.ml/tags/sysadmin/"/>
    
    <category term="rsync" scheme="https://blog.clam.ml/tags/rsync/"/>
    
    <category term="selinux" scheme="https://blog.clam.ml/tags/selinux/"/>
    
    <category term="mirroring" scheme="https://blog.clam.ml/tags/mirroring/"/>
    
  </entry>
  
  <entry>
    <title>Ptt/Ptt2 近期對於 SSH 連線實作的更動</title>
    <link href="https://blog.clam.ml/2021/07/04/ptt-is-testing-new-sshd/"/>
    <id>https://blog.clam.ml/2021/07/04/ptt-is-testing-new-sshd/</id>
    <published>2021-07-04T09:49:11.000Z</published>
    <updated>2021-07-25T11:59:20.003Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章將以使用者與 BBS 程式測試者的角度觀察，最近 PttBBS 對於 ssh 連線提供服務方式的更動，以及對於一般使用者可能造成的影響，此次更動相關的原始碼以及實作說明還沒被公開，因此若與往後官方說明有出入者，請以他們的為準。</p><p>近 10 年來，BBS 已然沒落，但批踢踢實業坊 (<a href="https://www.ptt.cc">PttBBS</a>) 依然因為對於社會議題輿論產生重大影響、多位 app 開發者提供第三方手機連線服務…等因素，在尖峰時間維持數萬 ~ 十幾萬人次的同時上線人數。</p><p>然而近幾年以來卻開始愈來愈頻繁地發生尖峰時間 Ptt 無法正常登入的負載問題，尤其在近幾個月來更是出現一般使用者認為中規模的事件，如：小區域地震、三級警戒以來每天召開的防疫記者會，Ptt 也仍因過載無法登入的窘況。也開始引發各看板，包含 <a href="https://www.ptt.cc/bbs/SYSOP/">SYSOP 站務板</a>大大小小的抱怨。</p><p>對此站方有什麼積極應對解決的方案呢？其實是有的。以下根據初步觀察大概分成四個階段：觀察、分析、嘗試方案、解決(正式上線)</p><span id="more"></span><h2 id="觀察">觀察</h2><p>為了確認各種連線問題造成的原因，首先 Ptt 站務總監 okcool 先在理論上較多針對 Ptt 的 App 開發者所在看板：<a href="https://www.ptt.cc/bbs/AppsForBBS/index.html">AppsForBBS 板</a>，籲請各 App 開發者在使用 websocket 連線登入時，配合加上 User-Agent 資訊，以方便統計各軟體使用 Websocket 的連線狀況。</p><p>至於其他連線方式(ssh, telnet)，根據既有的公開程式可以得知都會留下相關記錄，因此這方面就不再說明了。</p><h2 id="分析與討論">分析與討論</h2><p>另外在 Ptt、Ptt2 SYSOP 板爬梳一些討論資料，以及 <a href="https://github.com/ptt/pttbbs">PttBBS 原始碼</a>、<a href="https://www.ptt.cc/bbs/PttCurrent/">PttCurrent 板</a>提供的相關文件後，我們可以找到當初 PttBBS 可以承受同時間 15~6 萬人上線，關鍵在於 PttBBS 會經由 logind 程式接收大量 telnet 連線並為各 Client 顯示登入畫面，登入成功後再導入 mbbsd 進行主要的 bbs 指令操作。</p><p>然而，ssh 連線方式的實作則是直接在 Linux Server 開一個 <code>bbs</code> / <code>bbsu</code> 帳號，login shell 分別設爲 <code>/home/bbs/bin/bbsrf</code> 和 <code>/home/bbs/bin/utf8</code> ( symbolic link 到 <code>/home/bbs/bin/bbsrf</code> )，連線成功後即直接開啟 mbbsd 程式進行登入程序。</p><p>引用 BBS 開發者 <a href="https://github.com/IepIweidieng">IepIweidieng(github)</a> 在 <a href="https://discord.ccns.io">CCNS Discord</a> #bbs-dev 的<a href="https://discord.com/channels/330361502643257345/370600485612290060/843869940427522099">描述</a>:</p><blockquote><p><code>logind</code> 在使用者成功登入後才會將使用者的 <code>fd</code> 轉交給 <code>mbbsd</code> 並進行 <code>fork()</code>。<code>mbbsd</code> daemon 模式則是一連線就會 <code>fork()</code>。非 daemon 模式則是完全從頭啟動。</p></blockquote><p>而 PttBBS 傳統上給 ssh 連線用的就是 <code>mbbsd</code> 的非 daemon 模式，<code>fork()</code> 的工作則是交給 OpenSSH Server 的 <code>sshd</code> 來進行。</p><p><img src="https://i.imgur.com/P6w4fjq.png" alt=""></p><p>因此給 PttBBS 用的 <code>logind</code> 效能如何是 PttBBS 開發者可以研究如何改善的，但 OpenSSH Server 的效能調校能改的就相對有限了。</p><p>近年來加密連線防範封包側錄的資訊安全意識興起，ssh 連線被各使用者、手機 Apps 預設值，甚至是 BBS 爬蟲程式(如: <a href="https://github.com/PttCodingMan/PyPtt">PyPtt</a>) 大量採用，因此也開始被懷疑是影響 PttBBS 近年處理大量連線的效能瓶頸。</p><h2 id="嘗試方案-暫停-ssh-連線-觀察">嘗試方案: 暫停 ssh 連線 -&gt; 觀察</h2><p>今年 5 月，COVID-19 在臺灣的本土疫情爆發，因此 PttBBS 遇到的連線效能瓶頸也更加明顯，那段期間在每日 12pm 就會開始出現系統過載的畫面了，更別說是 2pm 召開防疫記者會的時候。那時候站方還有在 SYSOP 板發布<a href="https://www.ptt.cc/bbs/SYSOP/M.1621416649.A.5E7.html">公告</a>，籲請使用者盡量改用 Websocket 加密連線方式來代替。但這樣的籲請措施能做的還是有限，一來 Websocket for BBS 在終端機上還沒有一個相對方便的指令連線方案，另外就是會有使用者反應在尖峯時段用 ssh 連線「搶」進去的機率反而比較高。</p><p>另外在該期間，Ptt 也<a href="https://www.ptt.cc/bbs/PttNewhand/M.1621264236.A.23D.html">暫停</a>了 ssh 連線登入。我們目前認為是作為確認 ssh 造成連線壅塞原因的手段。</p><h2 id="站方解決方案：以-logind-為基礎重新實作-SSH-server">站方解決方案：以 logind 為基礎重新實作 SSH server</h2><p>今年 5/31，Ptt 系統站長 robertabcd 在 <a href="https://term.ptt2.cc">ptt2.cc</a> 發佈公告 ( <code>#1Wj4MGKt (SYSOP)</code> )，宣佈開始在 ptt2 測試新版 SSH。雖然該次以失敗(原因: 部分 client, 如 PuTTY, 登入畫面顯示仍有問題)，但也為 BBS 提供 SSH 連線兼顧效能的可行性，增添了不小的可能。</p><p>後來在 6/7，新版 SSH 再度上線(<code>#1WlJ2MXQ (SYSOP) [ptt2.cc]</code>)，這次使用者操作方面穩定性就提升了不少，也因此過了數天後就上線到 <a href="http://ptt.cc">ptt.cc</a>。這部分也可以從 <code>telnet</code> 或 <code>nc</code> 等工具程式針對 port 22 測試而得知。 (<code>telnet ptt.cc 22</code>)</p><p>以往會得到類似以下結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ telnet ptt.cc 22                                                                                        [17:37:31]</span><br><span class="line">Trying 140.112.172.2...</span><br><span class="line">Connected to ptt.cc.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">SSH-2.0-OpenSSH_8.4p1</span><br></pre></td></tr></table></figure><p>現在則是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ telnet ptt.cc 22                                                                                        [17:37:31]</span><br><span class="line">Trying 140.112.172.2...</span><br><span class="line">Connected to ptt.cc.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">SSH-2.0-bbs-sshd</span><br></pre></td></tr></table></figure><p>由於 OpenSSH 的版本號碼顯示只能在編譯階段修改，且新版 SSH server 版號顯示也拿掉了 OpenSSH 字樣，因此我們推測新版程式是利用 <a href="https://www.libssh.org/">libssh</a> 結合既有的 logind 提供服務，使透過 SSH 大量登入的連線可以順利交給 <code>logind</code> 處理，解決原本方法在這時產生的效能瓶頸。</p><p><img src="https://i.imgur.com/rphrOxQ.png" alt="7/3 當日使用者上線統計"><br><img src="https://i.imgur.com/6aPiuHM.png" alt="5/13 當日使用者上線統計"></p><p>目前從 <em>主選單 &gt; (X) &gt; (U) &gt; (Y) &gt; (U)</em> 進入昨日使用者統計來觀察 ptt 一天上線人次，已經不若以往每逢尖峰時間必過載的情形發生。但實際上而言能夠承受的密集大量登入程度為何，仍有待時間的考驗，以及是否有重大事件足以提供測試的契機了。</p><h2 id="結語">結語</h2><p>在有限的資源下維護開源專案都是不容易的，尤其因為 Ptt 的特殊性質，更難以導入用別人錢(贊助)就可以解決問題的方案。在這樣情況下還能有這樣進展，我們或許該充分體認到這類的事情都不是理所當然的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇文章將以使用者與 BBS 程式測試者的角度觀察，最近 PttBBS 對於 ssh 連線提供服務方式的更動，以及對於一般使用者可能造成的影響，此次更動相關的原始碼以及實作說明還沒被公開，因此若與往後官方說明有出入者，請以他們的為準。&lt;/p&gt;
&lt;p&gt;近 10 年來，BBS 已然沒落，但批踢踢實業坊 (&lt;a href=&quot;https://www.ptt.cc&quot;&gt;PttBBS&lt;/a&gt;) 依然因為對於社會議題輿論產生重大影響、多位 app 開發者提供第三方手機連線服務…等因素，在尖峰時間維持數萬 ~ 十幾萬人次的同時上線人數。&lt;/p&gt;
&lt;p&gt;然而近幾年以來卻開始愈來愈頻繁地發生尖峰時間 Ptt 無法正常登入的負載問題，尤其在近幾個月來更是出現一般使用者認為中規模的事件，如：小區域地震、三級警戒以來每天召開的防疫記者會，Ptt 也仍因過載無法登入的窘況。也開始引發各看板，包含 &lt;a href=&quot;https://www.ptt.cc/bbs/SYSOP/&quot;&gt;SYSOP 站務板&lt;/a&gt;大大小小的抱怨。&lt;/p&gt;
&lt;p&gt;對此站方有什麼積極應對解決的方案呢？其實是有的。以下根據初步觀察大概分成四個階段：觀察、分析、嘗試方案、解決(正式上線)&lt;/p&gt;</summary>
    
    
    
    
    <category term="opensource" scheme="https://blog.clam.ml/tags/opensource/"/>
    
    <category term="foss" scheme="https://blog.clam.ml/tags/foss/"/>
    
    <category term="ptt" scheme="https://blog.clam.ml/tags/ptt/"/>
    
    <category term="ptt2" scheme="https://blog.clam.ml/tags/ptt2/"/>
    
    <category term="bbs" scheme="https://blog.clam.ml/tags/bbs/"/>
    
    <category term="maplebbs" scheme="https://blog.clam.ml/tags/maplebbs/"/>
    
    <category term="openssh" scheme="https://blog.clam.ml/tags/openssh/"/>
    
    <category term="libssh" scheme="https://blog.clam.ml/tags/libssh/"/>
    
  </entry>
  
  <entry>
    <title>PyGMT, 在 Python 製圖領域推廣 GMT 的利器? 我 ok, 你先用?</title>
    <link href="https://blog.clam.ml/2021/06/21/pygmt-2021-6-feedback/"/>
    <id>https://blog.clam.ml/2021/06/21/pygmt-2021-6-feedback/</id>
    <published>2021-06-20T23:37:03.000Z</published>
    <updated>2021-07-25T11:59:20.003Z</updated>
    
    <content type="html"><![CDATA[<p>Generic Mapping Tools，通用製圖工具，官方以及常見的簡稱為 GMT，是在地球科學領域廣泛使用的地理製圖工具之一。它可以在各種平臺結合 Shell Script (bash、csh)，Batch file(Windows) 的特性以及第三方工具(如: awk)，撰寫腳本以進行空間資訊的數據處理及高度客製化的地圖、圖表繪製。PyGMT 於 2020 年 5 月釋出，作為 GMT 在 Python 的 API。究竟這樣的專案對於 GMT 的使用族群而言有什麼可利用之處呢？以下分享個人的使用心得。</p><span id="more"></span><h2 id="GMT-與-PyGMT-介紹">GMT 與 PyGMT 介紹</h2><p>Generic Mapping Tools，通用製圖工具，官方以及常見的簡稱為 GMT。於 1988 年釋出第一個 1.0 版本，並且受<a href="http://www.nsf.gov/">美國國家科學基金會 (NSF)</a>的贊助持續開發至今，在 2021 年 6 月 5 日已經釋出 6.2.0 版本，是在地球科學領域廣泛使用的地理製圖工具之一。它可以在各種平臺結合 Shell Script (bash、csh)，Batch file(Windows) 的特性以及第三方工具(如: awk)，撰寫腳本以進行空間資訊的數據處理及高度客製化的地圖、圖表繪製。</p><p>GMT 團隊在 5.x 版釋出時，就已經積極投入應用程式介面(API)的開發，並陸續開發了 Fortran，MATLAB/Octave，Julia 等語言的 API。GMT 6.x 於 2019 年釋出後，於隔年 5 月便有了 GMT 在 Python 的 API，被命名為 PyGMT 專案。讓使用者能夠利用 Python 語法呼叫 PyGMT 提供的函式透過 GMT 的官方 API (而非透過 Shell 呼叫)進行製圖腳本的撰寫。究竟這樣的專案對於 GMT 的使用族群而言有什麼可利用之處呢？以下分享個人的使用心得。</p><h2 id="PyGMT-潛在優勢">PyGMT 潛在優勢</h2><p>以下先分享使用 PyGMT 的好處：</p><ol><li>可以更輕鬆地結合在 Python 更為強大的套件(<code>pandas</code>，<code>numpy</code>，<code>obspy</code>)進行科學數據的運算與結果製圖</li><li>避開對系統 Shell 的直接呼叫，以提升以 GMT 為基礎建構應用程式的安全性。(相對於很多人偷懶直接使用 <code>system()</code> 直接呼叫 <code>gmt</code> 指令)</li><li>在 PyGMT 函數內的參數名稱，會設計成一般人較容易理解的長參數名稱，相較於 GMT 在 shell 指令的選項以短參數為主，可讀性大幅提升</li></ol><p>關於參數名稱的部分，這邊引用並微幅修改 <a href="https://gmt-tutorials.org/making_first_map.html">GMT 教學手冊</a> 的範例作為對照。</p><p>預計出來的原圖如下：<br><img src="https://gmt-tutorials.org/_images/making_first_map_gmt6_fig4.png" alt=""></p><p>若使用 GMT 5 的語法在 Shell 進行製圖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gmt pscoast \</span><br><span class="line">    -R19.42/22.95/59.71/60.56 \</span><br><span class="line">    -JM6i \</span><br><span class="line">    -W0.1p,black \</span><br><span class="line">    -Gdarkseagreen2 \</span><br><span class="line">    -Scornflowerblue \</span><br><span class="line">    -Df \</span><br><span class="line">    -P \</span><br><span class="line">    -Ba2f0.5g1 \</span><br><span class="line">    -BWSne+t<span class="string">&quot;Archipelago Sea&quot;</span> \</span><br><span class="line">    -A0.1 \</span><br><span class="line">    -U &gt; archi_sea.ps</span><br></pre></td></tr></table></figure><p>GMT 6 則是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gmt coast \</span><br><span class="line">    -R19.42/22.95/59.71/60.56 \</span><br><span class="line">    -JM6i \</span><br><span class="line">    -W0.1p,black \</span><br><span class="line">    -Gdarkseagreen2 \</span><br><span class="line">    -Scornflowerblue \</span><br><span class="line">    -Ba2f0.5g1 \</span><br><span class="line">    -BWSne+t<span class="string">&quot;Archipelago Sea&quot;</span> \</span><br><span class="line">    -A0.1 \</span><br><span class="line">    -U \</span><br><span class="line">    -png archi_sea</span><br></pre></td></tr></table></figure><p>而 PyGMT 則是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pygmt</span><br><span class="line">fig = pygmt.Figure()</span><br><span class="line">fig.coast(</span><br><span class="line">        region=[19.42, 22.95, 59.71, 60.56],</span><br><span class="line">        projection=&quot;M6i&quot;,</span><br><span class="line">        shorelines=[&#x27;0.1p&#x27;, &#x27;black&#x27;],</span><br><span class="line">        land=&#x27;darkseagreen2&#x27;,</span><br><span class="line">        water=&#x27;cornflowerblue&#x27;,</span><br><span class="line">        frame=[&#x27;a2f0.5g1&#x27;, &#x27;WSne+t&quot;Archipelago Sea&quot;&#x27;],</span><br><span class="line">        area_thresh=0.1,</span><br><span class="line">        timestamp=True,</span><br><span class="line">)</span><br><span class="line">fig.show()</span><br><span class="line">fig.savefig(&#x27;archi_sea_pygmt.png&#x27;)</span><br></pre></td></tr></table></figure><p>在查看文件之前，哪個腳本較能夠讓人直覺去猜到各參數的意義，相信答案已經很明顯了吧。</p><h2 id="PyGMT-的疑慮與待改進之處">PyGMT 的疑慮與待改進之處</h2><p>然而，相對於 GMT 的開發歷史，PyGMT 仍然是一個非常非常年輕的套件。縱使有了 NSF 的贊助，相對於其他類似規模的開源專案資源開發能量仍然十分有限。也因此我們可以輕易地找出許多理由，去建議剛接觸指令製圖的新手「先不要」輕易嘗試 PyGMT 這個套件。理由如下：</p><ol><li>PyGMT 支援的 GMT 模組數量仍然有限</li><li>即使某些 GMT 模組能被 PyGMT 支援，但能使用的長選項參數、能夠讀取的資料格式仍相對受限</li><li>開發/教學文件與範本數量仍極度缺乏，但此部分至少可以對照 GMT 指令版本的文件</li></ol><p>第 1,2 點的部分，以目前釋出的 0.3.1 版為例，該版本不支援、支援有限但常被使用的 GMT 指令模組包含了 <a href="https://docs.generic-mapping-tools.org/6.2/project.html"><code>project</code></a> (對平面直線附近包含深度資訊的座標點進行剖面繪製)，<a href="https://docs.generic-mapping-tools.org/6.2/supplements/seis/pssac.html"><code>pssac</code></a> (讀取 SAC 檔並繪製地震波形)， <a href="https://docs.generic-mapping-tools.org/6.2/histogram.html"><code>histogram</code></a> (繪製長條圖，目前已於 <a href="https://zh.wikipedia.org/zh-tw/Git">git</a> <code>master</code> 開發中版本開始支援)，<a href="https://docs.generic-mapping-tools.org/6.2/supplements/seis/meca.html"><code>meca</code></a> (舊稱 <code>psmeca</code>，已實作，但不支援震源機制球置放在震央以外的位置)…等。</p><p>即使 <code>pssac</code> 和 <code>histogram</code> 功能可分別用 <code>obspy</code> 和 <code>matplotlib</code> 替代，但使用介面上的差異，進而造成腳本轉換所要花費的時間，卻遠大於從 GMT 5,6 轉換到其他 PyGMT 支援的模組所要付出的。</p><p>另外在傳統 GMT 繪圖的過程中，我們需要 <code>-V</code> 選項來讓程式輸出更多明顯的提示訊息以利除錯校正，在 PyGMT 中開發者嘗試使用 <code>verbose=True</code> 使其參數更容易被理解，但大量使用此選項後便會發現許多函式仍然只能使用 <code>V=True</code> 來應付其 alias 無法實作的問題。</p><p>上面所遇到的問題會徒然花費使用者時間去想辦法應付這些問題，進而大幅降低使用者嘗試的意願。包含並不限於使用替代套件、透過 <code>pygmt.clib.Session.call_module()</code> 呼叫 API、回去使用 <code>subprocess</code>…等，其中必須用到 <code>subprocess()</code> 及其 pipe 功能來應付模組 <code>project</code> 不被 PyGMT 支援的問題時，已經開始思考當初使用這個套件的理由了。</p><h2 id="PyGMT-還有搞頭嗎">PyGMT 還有搞頭嗎?</h2><p>身為開源軟體的使用者、推廣者而言，仍然希望這個專案的開發能夠繼續下去。畢竟上面實際使用該套件後遇到的問題，多偏向開發、使用者社群尚未完整地建立起來的因素，再加上一般使用者多偏向從現有/舊有腳本去修改來繪製研究成果以節省時間，這也成為了推廣新工具(PyGMT，GMT 6 語法)、給予回饋的巨大阻礙。然而新需求、新方法總會不斷地出現，停留在舊版程式與腳本也遲早會遇到無法被新平臺、新工具支援的問題。如果我們持續停留在消耗別人既有成果而對於回饋開源專案這件事情不甚重視的話，未來能從它身上滿足的需求也將持續受限，無法跨出新的一步。</p><p>其他能做的事情，或許可以列舉：</p><ul><li>整理以上支援受限的 module 資訊，包含其必要性 (是否優於替代方案)，回報給開發者社群。</li><li>瞭解該專案 alias 實作方式，將能夠理解且需要修改的部分整理成新的 Pull Request (當然開發者搶先一步修好是更值得慶幸的)。</li><li>整理分享更多樣的繪圖腳本紀錄供社群參考，以利讓更多人在有意願嘗試時有個參考依據。</li></ul><p>對於那些前仆後繼在 GMT 相關專案投入大量心力改善軟體品質的前輩，個人也給予深深的尊敬與肯定，自己能做的除了以上那些，可能也只有幫忙打包新版的程式到自己習慣用的 Linux 發行版(Archlinux Arch Users Repository)，方便別人嘗鮮吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Generic Mapping Tools，通用製圖工具，官方以及常見的簡稱為 GMT，是在地球科學領域廣泛使用的地理製圖工具之一。它可以在各種平臺結合 Shell Script (bash、csh)，Batch file(Windows) 的特性以及第三方工具(如: awk)，撰寫腳本以進行空間資訊的數據處理及高度客製化的地圖、圖表繪製。PyGMT 於 2020 年 5 月釋出，作為 GMT 在 Python 的 API。究竟這樣的專案對於 GMT 的使用族群而言有什麼可利用之處呢？以下分享個人的使用心得。&lt;/p&gt;</summary>
    
    
    
    
    <category term="opensource" scheme="https://blog.clam.ml/tags/opensource/"/>
    
    <category term="genericmappingtools" scheme="https://blog.clam.ml/tags/genericmappingtools/"/>
    
    <category term="geophysics" scheme="https://blog.clam.ml/tags/geophysics/"/>
    
    <category term="earthscience" scheme="https://blog.clam.ml/tags/earthscience/"/>
    
    <category term="mapping" scheme="https://blog.clam.ml/tags/mapping/"/>
    
    <category term="python" scheme="https://blog.clam.ml/tags/python/"/>
    
    <category term="freesoftware" scheme="https://blog.clam.ml/tags/freesoftware/"/>
    
  </entry>
  
  <entry>
    <title>在 Debian/Ubuntu 等 Linux 發行版下簡易打包軟體 – 以 SAC 為例</title>
    <link href="https://blog.clam.ml/2021/06/06/sac-debian-packaging/"/>
    <id>https://blog.clam.ml/2021/06/06/sac-debian-packaging/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2021-07-25T11:59:20.003Z</updated>
    
    <content type="html"><![CDATA[<p>我們常見到的Linux 發行版基本上就是一個「拼裝車」，組合各個不同來源的專案原始碼組合成一個有多用途的「通用作業系統」。我們將以地震學軟體 SAC 為例，說明如何簡單利用「套件打包」的機制，藉由既有軟體打包管理工具，使得發行版內的軟體更能有秩序地被管理。</p><span id="more"></span><h2 id="套件打包的目的">套件打包的目的</h2><p>相對於 Windows、FreeBSD 作業系統都有官方維護的基礎元件(base component)，我們常見到的 Linux 發行版基本上就是一個全然的「拼裝車」，組合各個不同來源的專案原始碼組合成一個有實際用途的「<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F#%E9%80%9A%E7%94%A8%E4%B8%8E%E4%B8%93%E7%94%A8%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F">通用作業系統</a>」。通常發行版的維護者會優先將符合<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%8A%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6">自由及開放原始碼授權</a>的專案納入其關鍵元件，各個發行版看似五花八門，但終究離不開這個本質。少數發行版(如: Ubuntu Linux)在法律資源充足下會在安裝期間提供授權不相容(如: Nvidia 驅動、OpenZFS 核心模組)的元件以增進使用者體驗。但在大部分情況下，只要是授權有疑慮或明定不開放散佈原始碼的軟體，在發行版整合上就是一個巨大的阻礙，因為這意味者我們無法透過社群合作的機制，讓更熟悉軟體開發部署工程的人檢視我們平常使用的程式是否是易於使用、沒有潛在問題的。</p><p>而我們在 Unix-like (Linux、FreeBSD、Solaris、更早期的 SunOS…等) 環境下，最早期藉由原始碼安裝軟體方式，就是進入原始碼資料夾。執行 <code>make</code> 將軟體編譯完成後，再使用 root 權限 <code>make install</code>，將軟體安裝到預設的路徑 ( <code>/usr/local</code> ) 下。但現在我們已經極度不建議安裝用這樣的方式在預設路徑( <code>/usr/local</code> )，因為容易跟其他也手動安裝在同位置的套件混淆，使得嘗試解除安裝的過程中容易誤刪手動 <code>make install</code> 安裝其他套件的檔案，讓升級或解除安裝套件更加複雜。更別說在「不重複安裝」的前提下，解決 A 函式庫一更新，以它為基礎的 B 專案就得重新編譯才能找到 A 以執行的常見問題了。</p><p>因此我們開始使用了「套件打包」的機制，藉由單一專案的軟體打包管理程式(dpkg, rpm)，統一發行版內軟體管理的秩序。</p><h2 id="使用情境-–-為什麼要「打包」SAC">使用情境 – 為什麼要「打包」SAC?</h2><p>SAC 全名是 Seismic Analysis Code，是個歷史悠久的地震學資料處理軟體，由美國的 IRIS (地震學研究機構聯合會) 團隊開發，主要使用 C 語言開發，需在相容 Unix-like (如 Linux, FreeBSD, Cygwin…等) 的 X 視窗系統下才能正常使用，並只提供相關原始碼、執行檔給非特殊國家之地震學相關人員。若需取得相關程式需至官方網站<a href="https://ds.iris.edu/ds/nodes/dmc/forms/sac/">填寫申請表單</a>，由該單位人員審核後才可藉由 email 附件取得檔案。</p><p>傳統而言，在同一作業系統環境下安裝 SAC 有兩種途徑，第一種是直接把 IRIS 提供的執行檔手動放到指定位置 ( Linux 下指定 <code>/usr/local</code> ) 後執行，第二種是在作業系統下自行使用 gcc 等編譯器建置後安裝到自行指定的位置 (若未指定則仍安裝到 <code>/usr/local</code> )</p><p>第一種方法的方便之處在於說，不需要瞭解太多 Linux / Unix 的基礎知識與相關操作就可以藉由非常基本的指令 (cp, sudo…等) 完成安裝</p><p>缺點在於只能安裝在 <a href="https://zh.wikipedia.org/zh-tw/X86">x86</a>/<a href="https://zh.wikipedia.org/zh-tw/X86-64">x86_64</a> 平臺下的 CPU 才能順利執行的 Linux 執行檔，也就是說若你今天想在同樣安裝 Linux 的小型開發板 (如：樹梅派、Apple Silicon M1 上執行的虛擬機器)或是在官方沒考慮的 Unix-like 環境(Cygwin, FreeBSD, Termux)下執行是做不到的 (樹梅派或許可以在上面開 QEMU 模擬，但速度可預想是非常非常慢的)</p><p>另外第一種方法也無法自行客製化相關功能，這限制的問題在於說用此方法安裝的 SAC 程式只能在極度有限的操作體驗下進行，而使得剛熟悉 bash 等指令介面的使用者進入 SAC 的指令介面會發現 TAB 自動補完、上下、結束時保留指令歷史、Ctrl+R 搜尋歷史等在 bash 有的功能這邊都沒有或限制更多。但如果客製化編譯就可以藉由增加相關選項就可以改善。</p><p>因此我們知道如果藉由第二種方法有可修改安裝路徑、自行增減相關功能、移植更方便等優勢，但此方法對於沒有接觸過系統管理、程式開發的使用者挑戰並不小，且若想要提供給多個各自符合資格的人員，安裝一樣客製化設定同時符合易於安裝、升級、解除安裝原則的 SAC 程式也勢必會花費很多心力。此時發行版下的套件管理工具就是我們很重要的夥伴了! 在這邊我們將用 Debian/Ubuntu 下的 <code>apt</code> (<code>dpkg</code>) 工具來協助我們更輕易地部署「我們的 SAC」</p><h2 id="SAC-Debian-Ubuntu-Packager-介紹">SAC Debian/Ubuntu Packager 介紹</h2><p><img src="https://github.com/sean0921/sean0921.github.io/raw/3ef1e32d61fc62c546c6ba31ef526ccc050cc7b2/images/demo.gif" alt=""></p><p>這個工具使用最基本的 Shell Script 腳本，搭配 <code>dpkg</code> 程式，將編譯後的 SAC 程式放置在特定資料夾後，再加入軟體資訊後打包壓縮成單一安裝檔 (<code>&lt;pkg_name&gt;.deb</code>)，最後再由使用者從 <code>apt</code> 程式安裝該套件，納入發行版套件管理系統的記錄中。</p><p>由以上討論我們可以歸納這個方法的好處：</p><ol><li>使得 SAC 更易於安裝、解除安裝、升級</li><li>SAC 底層用到的函式庫一旦有重大升級，發行版套件管理程式（<code>apt</code>）會跳出相關警告，讓你記得要重新安裝程式。</li><li>減少繁瑣的環境變數設定</li></ol><p>使用這個工具安裝 SAC 之前，符合相關資格的使用者仍需自行至 IRIS 網站申請下載原始碼，以遵守授權相關規範。詳細安裝方式請參考 <a href="https://github.com/sean0921/sac_debian_packager">GitHub</a> 上的 README 頁面。</p><h2 id="結論">結論</h2><p>套件打包適合用在一定數量的人會安裝的軟體上，以減少繁瑣安裝過程中可能會出錯的機率，以增進效率並兼顧使用體驗。也是讓 Linux 在有限硬碟空間下提供完整功能的關鍵。若有心在未來的專案上利用 Linux 環境作為開發測試平臺，這仍然是不可或缺的知識。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我們常見到的Linux 發行版基本上就是一個「拼裝車」，組合各個不同來源的專案原始碼組合成一個有多用途的「通用作業系統」。我們將以地震學軟體 SAC 為例，說明如何簡單利用「套件打包」的機制，藉由既有軟體打包管理工具，使得發行版內的軟體更能有秩序地被管理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="packaging" scheme="https://blog.clam.ml/tags/packaging/"/>
    
    <category term="linux" scheme="https://blog.clam.ml/tags/linux/"/>
    
    <category term="sysadmin" scheme="https://blog.clam.ml/tags/sysadmin/"/>
    
    <category term="seismology" scheme="https://blog.clam.ml/tags/seismology/"/>
    
  </entry>
  
  <entry>
    <title>成為 Git 獨行玩家的第一步 － 自架 cgit 網頁程式碼瀏覽服務</title>
    <link href="https://blog.clam.ml/2021/03/27/be-a-git-single-player-cgit-tutorial/"/>
    <id>https://blog.clam.ml/2021/03/27/be-a-git-single-player-cgit-tutorial/</id>
    <published>2021-03-26T17:47:27.000Z</published>
    <updated>2021-07-25T11:59:20.003Z</updated>
    
    <content type="html"><![CDATA[<p>不想被單一特定程式碼平臺綁住你個人開發的程式碼又想將你的心血整合起來供其他人參考嗎? 又或是擔心在 GitHub 上一堆為了學術研究用途的專案哪一天被和諧掉嗎? 如果沒有多人合作 CI/CD 需求直接從網頁登入存取的需求 <code>cgit</code> 這個由 C 語言開發的網頁 cgi 服務, 簡潔又快速的功能或許可以輕易滿足你的需求喔</p><span id="more"></span><h2 id="步驟">步驟</h2><h3 id="1-環境配置">1. 環境配置</h3><h4 id="運行環境">運行環境</h4><p>任何 Unix-like 環境 ( Linux/FreeBSD/Cygwin/WSL ) 皆可, 本文章以 <em>Debian GNU/Linux Buster(10)</em> 為例進行解說, 相關過程指令也相容 <em>Ubuntu Linux</em>, <em>Debian GNU/Linux Bullseye(11)</em></p><h4 id="安裝相關套件">安裝相關套件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install cgit fcgiwrap nginx git python3-markdown</span><br></pre></td></tr></table></figure><h3 id="2-調校-nginx-cgit">2. 調校 nginx, cgit</h3><ul><li>刪除 <code>/etc/nginx/sites-&#123;enabled,available&#125;/default</code>, 用以下設定檔取代</li><li><code>/etc/nginx/conf.d/cgit.conf</code>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line"></span><br><span class="line">        # Add index.php to the list if you are using PHP</span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        server_name _;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">                #try_files $uri $uri/ =404;</span><br><span class="line">                try_files $uri @cgit;    ## 這邊要使用 cgit 的 CGI 程式來解譯路徑</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location /cgit-css/ &#123;</span><br><span class="line">                rewrite ^/cgit-css(/.*)$ $1 break;</span><br><span class="line">                root /usr/share/cgit;    ## cgit 的 CSS 排版格式與相關預設圖片需要它</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location @cgit &#123;</span><br><span class="line">                include             fastcgi_params;</span><br><span class="line"></span><br><span class="line">                # Path to the CGI script that comes with cgit</span><br><span class="line">                fastcgi_param       SCRIPT_FILENAME /usr/lib/cgit/cgit.cgi;</span><br><span class="line"></span><br><span class="line">                fastcgi_param       PATH_INFO       $uri;</span><br><span class="line">                fastcgi_param       QUERY_STRING    $args;</span><br><span class="line">                fastcgi_param       HTTP_HOST       $server_name;</span><br><span class="line"></span><br><span class="line">                # Path to the socket file that is created/used by fcgiwrap</span><br><span class="line">                fastcgi_pass        unix:/run/fcgiwrap.socket;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>/etc/cgitrc</code>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># cgit config</span><br><span class="line"># see cgitrc(5) for details</span><br><span class="line"></span><br><span class="line">## 這邊要搭配 nginx 設定的路徑來設定相關資源位置</span><br><span class="line">css=/cgit-css/cgit.css</span><br><span class="line">logo=/cgit-css/cgit.png</span><br><span class="line">favicon=/cgit-css/favicon.ico</span><br><span class="line"></span><br><span class="line"># if you don&#x27;t want that webcrawler (like google) index your site</span><br><span class="line">#robots=noindex, nofollow</span><br><span class="line"></span><br><span class="line">root-title=Andas valiendo verga</span><br><span class="line">root-desc=r2&#x27;s Git Repositories</span><br><span class="line"># if cgit messes up links, use a virtual-root. For example has cgit.example.org/ this value:</span><br><span class="line">virtual-root=/</span><br><span class="line">#virtual-root=/cgit.cgi/</span><br><span class="line">enable-http-clone=1</span><br><span class="line">cache-scanrc-ttl=1</span><br><span class="line">#remove-suffix=1</span><br><span class="line">#branch-sort=age</span><br><span class="line">local-time=1</span><br><span class="line">enable-blame=1</span><br><span class="line">enable-commit-graph=1</span><br><span class="line">enable-index-owner=1</span><br><span class="line">enable-log-filecount=1</span><br><span class="line">enable-log-linecount=1</span><br><span class="line">max-stats=year</span><br><span class="line">max-commit-count=250</span><br><span class="line">max-repo-count=250</span><br><span class="line">snapshots=tar.gz tar.zst</span><br><span class="line"></span><br><span class="line"># Specify some default clone urls using macro expansion</span><br><span class="line">#clone-url=http://myip/$CGIT_REPO_URL</span><br><span class="line"></span><br><span class="line"># Highlight source code with python pygments-based highligher</span><br><span class="line">source-filter=/usr/lib/cgit/filters/syntax-highlighting.py</span><br><span class="line"></span><br><span class="line"># Format markdown, restructuredtext, manpages, text files, and html files</span><br><span class="line"># through the right converters</span><br><span class="line">about-filter=/usr/lib/cgit/filters/about-formatting.sh</span><br><span class="line"></span><br><span class="line">enable-index-links=1</span><br><span class="line">root-readme=/my/gitrepos/git/readme.md</span><br><span class="line">#root-readme=/my/gitrepos/git/readme.html</span><br><span class="line"></span><br><span class="line">## 這邊可以幫你設定 cgit 掃描的 repo 所在資料夾</span><br><span class="line">scan-path=/srv/gitrepos/git/</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## List of common mimetypes</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">mimetype.gif=image/gif</span><br><span class="line">mimetype.html=text/html</span><br><span class="line">mimetype.jpg=image/jpeg</span><br><span class="line">mimetype.jpeg=image/jpeg</span><br><span class="line">mimetype.pdf=application/pdf</span><br><span class="line">mimetype.png=image/png</span><br><span class="line">mimetype.svg=image/svg+xml</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## Search for these files in the root of the default branch of repositories</span><br><span class="line">## for coming up with the about page:</span><br><span class="line">## 這邊如果沒安裝 python3-markdown 等套件的話README 仍然無法顯示 markdown 格式的喔</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">readme=:README.md</span><br><span class="line">readme=:readme.md</span><br><span class="line">readme=:README.mkd</span><br><span class="line">readme=:readme.mkd</span><br><span class="line">readme=:README.rst</span><br><span class="line">readme=:readme.rst</span><br><span class="line">readme=:README.html</span><br><span class="line">readme=:readme.html</span><br><span class="line">readme=:README.htm</span><br><span class="line">readme=:readme.htm</span><br><span class="line">readme=:README.txt</span><br><span class="line">readme=:readme.txt</span><br><span class="line">readme=:README</span><br><span class="line">readme=:readme</span><br><span class="line">readme=:INSTALL.md</span><br><span class="line">readme=:install.md</span><br><span class="line">readme=:INSTALL.mkd</span><br><span class="line">readme=:install.mkd</span><br><span class="line">readme=:INSTALL.rst</span><br><span class="line">readme=:install.rst</span><br><span class="line">readme=:INSTALL.html</span><br><span class="line">readme=:install.html</span><br><span class="line">readme=:INSTALL.htm</span><br><span class="line">readme=:install.htm</span><br><span class="line">readme=:INSTALL.txt</span><br><span class="line">readme=:install.txt</span><br><span class="line">readme=:INSTALL</span><br><span class="line">readme=:install</span><br><span class="line"></span><br><span class="line">###Catogory</span><br><span class="line">#scan-path=/my/gitrepos/git/</span><br><span class="line">## 這邊可以另外幫自己分類 git 專案</span><br><span class="line">#</span><br><span class="line">#section=a: BBS Projects</span><br><span class="line">#scan-path=/my/gitrepos/git/category/bbs</span><br><span class="line">#section=b: My Distro-Hacking Records</span><br><span class="line">#scan-path=/my/gitrepos/git/category/distro</span><br><span class="line">#section=c: My Personal Toys</span><br><span class="line">#scan-path=/my/gitrepos/git/category/mytoy</span><br></pre></td></tr></table></figure><h3 id="3-啟用服務與啟動服務">3. 啟用服務與啟動服務</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -t <span class="comment">## 檢查 nginx config 檔格式是否正確</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now nginx</span><br><span class="line">systemctl <span class="built_in">enable</span> --now fcgiwrap</span><br></pre></td></tr></table></figure><h3 id="4-1-抓取你想要鏡像的-git-repository">4-1. 抓取你想要鏡像的 git repository</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror https://github.com/&lt;github_user_name&gt;/&lt;github_repo_name&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-透過-git-ssh-server-設定你想要託管的-git-repository-optional">4-2. 透過 git+ssh server 設定你想要託管的 git repository (optional)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/bin/git-shell git</span><br><span class="line">sudo -su git cat &lt;place_of_your_ssh_public_key&gt; &gt;&gt; &lt;git_account_home&gt;/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="5-噹噹-開始使用你的服務">5. 噹噹! 開始使用你的服務</h3><p>輸入網址, 享用你的自架 git 服務: <code>http://&lt;your_cgit_ip_or_domain&gt;</code></p><p>若服務對外公開的話, 建議還是設定一下 TLS 安全連線比較保險一些</p><p>詳細 TLS 憑證設定與 Let’s Encrypt 憑證申請, 可以參考以下資源進行調整:</p><ul><li><a href="https://wiki.gslin.org/wiki/Let%27s_Encrypt">https://wiki.gslin.org/wiki/Let's_Encrypt</a></li><li><a href="https://ssl-config.mozilla.org/">https://ssl-config.mozilla.org/</a></li></ul><hr><p>我的 git repository: <a href="https://cgit.clam.ml">https://cgit.clam.ml</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不想被單一特定程式碼平臺綁住你個人開發的程式碼又想將你的心血整合起來供其他人參考嗎? 又或是擔心在 GitHub 上一堆為了學術研究用途的專案哪一天被和諧掉嗎? 如果沒有多人合作 CI/CD 需求直接從網頁登入存取的需求 &lt;code&gt;cgit&lt;/code&gt; 這個由 C 語言開發的網頁 cgi 服務, 簡潔又快速的功能或許可以輕易滿足你的需求喔&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://blog.clam.ml/tags/git/"/>
    
    <category term="cgit" scheme="https://blog.clam.ml/tags/cgit/"/>
    
    <category term="nginx" scheme="https://blog.clam.ml/tags/nginx/"/>
    
    <category term="fastcgi" scheme="https://blog.clam.ml/tags/fastcgi/"/>
    
    <category term="opensource" scheme="https://blog.clam.ml/tags/opensource/"/>
    
  </entry>
  
</feed>
