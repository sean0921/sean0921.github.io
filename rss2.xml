<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sean&#39;s Blog</title>
    <link>https://blog.clam.ml/</link>
    
    <atom:link href="https://blog.clam.ml/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>New Blog site construted by Hexo (nodejs package)</description>
    <pubDate>Fri, 15 Oct 2021 19:00:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Project CTPB 簡介</title>
      <link>https://blog.clam.ml/2021/08/22/project-ctpb/</link>
      <guid>https://blog.clam.ml/2021/08/22/project-ctpb/</guid>
      <pubDate>Sun, 22 Aug 2021 06:02:36 GMT</pubDate>
      
      <description>&lt;p&gt;在 2021 年，Linux 發行版等開源作業系統的普及率仍無法與 Microsoft Windows、Mac OS 等相比，但相關生態系與商業應用與 10 年前相比已有明顯成長，然而在 Linux 發行版的軟體安裝上，仍因為安裝方式不一，操作指令過於多樣，甚至多數商業軟體公司發行的開源/非開源套件是以「把所有用到函式庫都包在一起的方式」發行軟體，以方便忽視軟體相依性之問題，卻明顯違背了 Linux 發行版套件管理機制最初的用意。&lt;/p&gt;
&lt;p&gt;本專案，Clam-Test Package Build Project，簡稱 Project CTPB，藉由簡化、粗略的套件打包原理，提供各(非滾動式為主)發行版沒有提供，或是有提供但版本無法滿足特定需求的客製化套件。以滿足個人與特定需求使用者需要。並將相關步驟原理整理起來，作為研究、討論、交流、推廣等用途。往後相關資訊將會更新在本文章內文。或是以 &lt;em&gt;pj-ctpb&lt;/em&gt; 的標籤發表新的 blog 系列文章，以供各界朋友指教。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在 2021 年，Linux 發行版等開源作業系統的普及率仍無法與 Microsoft Windows、Mac OS 等相比，但相關生態系與商業應用與 10 年前相比已有明顯成長，然而在 Linux 發行版的軟體安裝上，仍因為安裝方式不一，操作指令過於多樣，甚至多數商業軟體公司發行的開源/非開源套件是以「把所有用到函式庫都包在一起的方式」發行軟體，以方便忽視軟體相依性之問題，卻明顯違背了 Linux 發行版套件管理機制最初的用意。</p><p>本專案，Clam-Test Package Build Project，簡稱 Project CTPB，藉由簡化、粗略的套件打包原理，提供各(非滾動式為主)發行版沒有提供，或是有提供但版本無法滿足特定需求的客製化套件。以滿足個人與特定需求使用者需要。並將相關步驟原理整理起來，作為研究、討論、交流、推廣等用途。往後相關資訊將會更新在本文章內文。或是以 <em>pj-ctpb</em> 的標籤發表新的 blog 系列文章，以供各界朋友指教。</p><span id="more"></span><h2 id="第一階段-apt-ftparchive-gpg-github-page">第一階段: apt-ftparchive + gpg + github-page</h2><ul><li>網址: <a href="https://gh.pkg.clam.ml/">https://gh.pkg.clam.ml/</a></li></ul><p>To be continued…</p>]]></content:encoded>
      
      
      
      <category domain="https://blog.clam.ml/tags/packaging/">packaging</category>
      
      <category domain="https://blog.clam.ml/tags/linux/">linux</category>
      
      <category domain="https://blog.clam.ml/tags/opensource/">opensource</category>
      
      <category domain="https://blog.clam.ml/tags/pj-ctpb/">pj-ctpb</category>
      
      
      <comments>https://blog.clam.ml/2021/08/22/project-ctpb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在 SELinux 環境下建立發行版鏡像站需要處理的權限問題</title>
      <link>https://blog.clam.ml/2021/07/25/rsync-tmp-file-under-selinux/</link>
      <guid>https://blog.clam.ml/2021/07/25/rsync-tmp-file-under-selinux/</guid>
      <pubDate>Sun, 25 Jul 2021 10:34:20 GMT</pubDate>
      
      <description>&lt;p&gt;這篇筆記主要描述如何從 rsync 運作原理，來理解在 SELinux 啟用的情況下，如何正確設定 rsync 暫存區路徑參數與暫存目錄權限。rsync 接收同步資料時，會先將抓取未驗證的檔案放在暫存目錄，經校驗無誤後再移動到同步目的地。如果 rsync 設定 &lt;code&gt;--temp-file&lt;/code&gt; 目錄路徑的預設 context 與目的地目錄的不同，則會發生目的地出現檔案實際 context 與該路徑下預設內容不符的情況，進而造成服務讀取時發生權限錯誤問題。解決方法有二: 1. 將暫存目錄的 context 設定成和同步目的地的一樣。 2. 取消設置 &lt;code&gt;--temp-file&lt;/code&gt; 參數，此時未驗證的暫存檔就會存放在同步目的地所在的目錄底下。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>這篇筆記主要描述如何從 rsync 運作原理，來理解在 SELinux 啟用的情況下，如何正確設定 rsync 暫存區路徑參數與暫存目錄權限。rsync 接收同步資料時，會先將抓取未驗證的檔案放在暫存目錄，經校驗無誤後再移動到同步目的地。如果 rsync 設定 <code>--temp-file</code> 目錄路徑的預設 context 與目的地目錄的不同，則會發生目的地出現檔案實際 context 與該路徑下預設內容不符的情況，進而造成服務讀取時發生權限錯誤問題。解決方法有二: 1. 將暫存目錄的 context 設定成和同步目的地的一樣。 2. 取消設置 <code>--temp-file</code> 參數，此時未驗證的暫存檔就會存放在同步目的地所在的目錄底下。</p><span id="more"></span><h2 id="簡介">簡介</h2><p>SELinux 是讓 Linux 系統管理者又愛又恨的安全性模組之一，它可以保護我們避免自己或他人不恰當的資源誤用，但更多時候我們則是被它複雜的權限設定所困惑，進而將其設定為 Permissive 甚至是 Disabled 來逃避現實。這篇筆記主要描述如何從 rsync 運作原理，來理解在 SELinux 啟用的情況下，如何正確設定 rsync 暫存區路徑參數與暫存區權限。</p><h2 id="會用到的-SELinux-觀念">會用到的 SELinux 觀念</h2><p>從鳥哥的中文文件<sub><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php#selinux">1</a></sub>以及 Red Hat 的官方文件<sub><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/index">2</a></sub>我們可以大致理解 SELinux 主要想管理重點包含「程序是否能正確讀取『對應』的檔案資源」。</p><p>以使用 <a href="https://zh.wikipedia.org/wiki/Nginx">nginx</a> 架設單純的靜態網頁伺服器為例，我們只預期外部使用者 <a href="https://zh.wikipedia.org/wiki/Nginx">nginx</a> 只會存取到: <code>/var/www/html/</code> 或是 <code>/usr/share/nginx/html</code> 的內容，其他非經管理者允許，不小心或刻意讀取到其他路徑下的檔案內容的行為可能都是「邪魔歪道」。</p><p>因此我們會發現利用 <code>ls -Z</code> 列出類似路徑下的檔案參數內容，多會顯示帶有 <code>httpd_sys_content_t</code> 這個標籤，表示這些檔案可以被特定的 http 服務存取，例如 Nginx 或 Apache。</p><p>照這樣來看，如果想要透過 http server 把檔案分享給別人，讓其他路徑下的檔案也能被 http server 存取的方法就是透過 selinux 的管理指令: <code>semanage</code>，將該路徑底下的預設檔案標籤也設定為 <code>httpd_sys_content_t</code></p><p>如果我們想讓檔案能透過其他的公開服務來存取 (ftp, rsync…)，我們還可以把標籤設定成 <code>public_content_t</code>。</p><p>這大概就是我們設定 SELinux 相關內容前，大概要理解的觀念</p><h2 id="會用到的-rsync-觀念">會用到的 rsync 觀念</h2><p>把 rsync 用到的觀念講得最簡明扼要的文件大概就是它自己的官方文件了<sub><a href="https://rsync.samba.org/how-rsync-works.html">3</a></sub></p><p>文件把該 rsync 套件會用到的角色(或程序)分成: client, server, daemon, remote shell, sender, receiver, generator</p><p>以我們想要同步上游 rsync 鏡像站為例，我們是 client，他們是 server，他們同時也有 daemon 的角色(持續地在背景跑 <code>rsyncd</code>)，也因此我們不會用到 remote shell，也就是不會透過 <a href="https://zh.wikipedia.org/wiki/Secure_Shell"><code>ssh</code></a>, <a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E5%A4%96%E5%A3%B3"><code>rsh</code></a>… 等傳輸協定來存取他們的 rsync 服務，而是使用 rsync 自己的協定。他們接受我們要求傳檔案給我們，我們接收檔案，所以 sender 會跑在他們那邊，我們是則會跑 receiver，並在接收到檔案列表後 fork 出 generator 和 receiver，分別進行檔案檢查與接收檔案的工作。</p><p>其中我比較在意的部分在 The Receiver 那邊提到的:</p><blockquote><p>The file’s checksum is generated as the temp-file is built. At the end of the file, <em><strong>this checksum is compared with the file checksum from the sender. If the file checksums do not match the temp-file is deleted.</strong></em><br>…<br>After the temp-file has been completed, its ownership and permissions and modification time are set. It is then <em><strong>renamed to replace the basis file</strong></em>.</p></blockquote><p>以及 <code>rsync(1)</code> man page<sub><a href="https://man7.org/linux/man-pages/man1/rsync.1.html">4</a></sub>提到的:</p><blockquote><p>This (<code>--checksum</code>) changes the way rsync checks if the files have been changed and are in need of  a  transfer.   Without  this  option, rsync  uses a  “quick check” that (by default) checks if each <em><strong>file’s size</strong></em> and <em><strong>time of last modification</strong></em> match between the sender and receiver.</p></blockquote><p>也就是說</p><ol><li>如果有啟用 <code>--checksum</code> 參數，在確認 checksum (聽說較新版本 rsync 是用 MD5) 沒問題後，temp file 就會從暫存路徑移動到目的地路徑取代原始檔案。</li><li>如果沒有啟用  <code>--checksum</code> 參數，rsync 會使用「快速檢查行為」(“quick check” behavior)，確認最後修改時間和檔案大小沒問題後，temp file 就會從暫存路徑移動到目的地路徑取代原始檔案。</li></ol><p>結果是一樣的，<em>會從暫存路徑移動到目的地路徑取代原始檔案</em>，只是檢查機制不同，<code>--checksum</code> 會比較嚴格一點。</p><h2 id="實例解說-在-SELinux-啟用的系統上鏡像-Arch-Linux-套件庫">實例解說: 在 SELinux 啟用的系統上鏡像 Arch Linux 套件庫</h2><p>Arch Linux 是一個相當新穎、簡潔的 <strong>x86_64</strong> 發行版，注意這邊也因為它官方只支援 x86_64 這個架構，因此實際把它官方套件庫的全部檔案抓下來，會發現不含 iso 檔大概只有 70 GiB 不到 ( Ubuntu 官方套件庫不含 iso 檔大概要佔用將近 1.5T 的容量)。也因此較適合拿來用一般的硬體資源來練習架設鏡像站。</p><p>但如果我們使用 Arch Linux 官方附的建議腳本<sub><a href="https://gitlab.archlinux.org/archlinux/infrastructure/-/blob/master/roles/syncrepo/files/syncrepo-template.sh">5</a></sub>來同步上游 rsync mirror 的套件庫，並把每個留白的參數都根據自己需求填入資訊，會發生什麼事情呢?</p><p>首先，假設我們要存放 mirror 內容的路徑是 <code>/mnt/mirror</code>，我們仍先把要共享 mirror 檔案內容的目錄及其下所有檔案的標籤都設爲 <code>public_content_t</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semanage fcontext -a -t public_content_t &quot;/mnt/mirror(/.*)?&quot;</span><br><span class="line">restorecon -Rv /mnt/mirror</span><br></pre></td></tr></table></figure><p>接著再來執行我們修改過後的同步腳本，然後回去 <code>ls -Z</code> 看看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unconfined_u:object_r:unlabeled_t:s0 community</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 community-staging</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 community-testing</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 core</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 extra</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 gnome-unstable</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 images</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 kde-unstable</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastsync</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastupdate</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 multilib</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 multilib-staging</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 multilib-testing</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 pool</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 staging</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 testing</span><br></pre></td></tr></table></figure><p>咦? 我們沒看錯吧? 於是我們再次 <code>restorecon -Rv /mnt/mirror</code> 後，等待下次更新:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unconfined_u:object_r:public_content_t:s0 community</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 core</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 extra</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 gnome-unstable</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 images</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 kde-unstable</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastsync</span><br><span class="line">unconfined_u:object_r:unlabeled_t:s0 lastupdate</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 pool</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 testing</span><br></pre></td></tr></table></figure><p>現在變成有被更新的檔案都會被 unlabeled 了，這是為什麼呢?</p><p>後來經歷一連串的測試之後，終於確定了問題出在 <code>--temp-file</code> 的這個參數，假設我們藉由該參數設定 rsync 暫存路徑為 <code>/mnt/mirror_tmp</code>，接下來我們來進行一個小實驗，任意設定該路徑的 selinux 標籤，改成對 rsync client 沒任何用途的 <code>rsync_tmp_t</code>，並把 <code>/mnt/mirror</code> 的標籤回復後，等待下次進行同步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unconfined_u:object_r:public_content_t:s0 community</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 community-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 core</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 extra</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 gnome-unstable</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 images</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 kde-unstable</span><br><span class="line">unconfined_u:object_r:rsync_tmp_t:s0 lastsync</span><br><span class="line">unconfined_u:object_r:rsync_tmp_t:s0 lastupdate</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 multilib-testing</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 pool</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 staging</span><br><span class="line">unconfined_u:object_r:public_content_t:s0 testing</span><br></pre></td></tr></table></figure><p>此時有被更新過檔案的 selinux 標籤就變成了 <code>rsync_tmp_t</code> 了</p><h3 id="小結">小結</h3><p>於是我們可以確定：</p><p>如果給 rsync 用的暫存目錄 ( <code>--temp-dir</code> ) 放在 selinux context 設定路徑以外的地方，就會使得 rsync 同步完後的 context 變成預期外的內容，進而造成 selinux 的權限錯誤。</p><h3 id="解決方案">解決方案</h3><ol><li>把 temp dir 的 context 設定成和同步目的地一樣的內容</li><li>不要設定 <code>--temp-dir</code> 參數 (這樣暫存檔的位置就會同步目的地一樣的目錄底下)</li></ol><h2 id="總結">總結</h2><p>雖然 SELinux 對於系統管理者在資源的運用上給予了相當多綁手綁腳的限制，但釐清相關運作流程的觀念與細節之後，就可以讓 SELinux 成為使得 Linux 系統服務安全的重要夥伴。這次在 rsync 同步雖然也踩到這個一開始令人困惑的問題，但同樣也藉此進一步地理解了 rsync 相關運作流程和 SELinux 觀念，給予了我們不小啟發。</p>]]></content:encoded>
      
      
      
      <category domain="https://blog.clam.ml/tags/linux/">linux</category>
      
      <category domain="https://blog.clam.ml/tags/sysadmin/">sysadmin</category>
      
      <category domain="https://blog.clam.ml/tags/rsync/">rsync</category>
      
      <category domain="https://blog.clam.ml/tags/selinux/">selinux</category>
      
      <category domain="https://blog.clam.ml/tags/mirroring/">mirroring</category>
      
      
      <comments>https://blog.clam.ml/2021/07/25/rsync-tmp-file-under-selinux/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ptt/Ptt2 近期對於 SSH 連線實作的更動</title>
      <link>https://blog.clam.ml/2021/07/04/ptt-is-testing-new-sshd/</link>
      <guid>https://blog.clam.ml/2021/07/04/ptt-is-testing-new-sshd/</guid>
      <pubDate>Sun, 04 Jul 2021 09:49:11 GMT</pubDate>
      
      <description>&lt;p&gt;本篇文章將以使用者與 BBS 程式測試者的角度觀察，最近 PttBBS 對於 ssh 連線提供服務方式的更動，以及對於一般使用者可能造成的影響，此次更動相關的原始碼以及實作說明還沒被公開，因此若與往後官方說明有出入者，請以他們的為準。&lt;/p&gt;
&lt;p&gt;近 10 年來，BBS 已然沒落，但批踢踢實業坊 (&lt;a href=&quot;https://www.ptt.cc&quot;&gt;PttBBS&lt;/a&gt;) 依然因為對於社會議題輿論產生重大影響、多位 app 開發者提供第三方手機連線服務…等因素，在尖峰時間維持數萬 ~ 十幾萬人次的同時上線人數。&lt;/p&gt;
&lt;p&gt;然而近幾年以來卻開始愈來愈頻繁地發生尖峰時間 Ptt 無法正常登入的負載問題，尤其在近幾個月來更是出現一般使用者認為中規模的事件，如：小區域地震、三級警戒以來每天召開的防疫記者會，Ptt 也仍因過載無法登入的窘況。也開始引發各看板，包含 &lt;a href=&quot;https://www.ptt.cc/bbs/SYSOP/&quot;&gt;SYSOP 站務板&lt;/a&gt;大大小小的抱怨。&lt;/p&gt;
&lt;p&gt;對此站方有什麼積極應對解決的方案呢？其實是有的。以下根據初步觀察大概分成四個階段：觀察、分析、嘗試方案、解決(正式上線)&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本篇文章將以使用者與 BBS 程式測試者的角度觀察，最近 PttBBS 對於 ssh 連線提供服務方式的更動，以及對於一般使用者可能造成的影響，此次更動相關的原始碼以及實作說明還沒被公開，因此若與往後官方說明有出入者，請以他們的為準。</p><p>近 10 年來，BBS 已然沒落，但批踢踢實業坊 (<a href="https://www.ptt.cc">PttBBS</a>) 依然因為對於社會議題輿論產生重大影響、多位 app 開發者提供第三方手機連線服務…等因素，在尖峰時間維持數萬 ~ 十幾萬人次的同時上線人數。</p><p>然而近幾年以來卻開始愈來愈頻繁地發生尖峰時間 Ptt 無法正常登入的負載問題，尤其在近幾個月來更是出現一般使用者認為中規模的事件，如：小區域地震、三級警戒以來每天召開的防疫記者會，Ptt 也仍因過載無法登入的窘況。也開始引發各看板，包含 <a href="https://www.ptt.cc/bbs/SYSOP/">SYSOP 站務板</a>大大小小的抱怨。</p><p>對此站方有什麼積極應對解決的方案呢？其實是有的。以下根據初步觀察大概分成四個階段：觀察、分析、嘗試方案、解決(正式上線)</p><span id="more"></span><h2 id="觀察">觀察</h2><p>為了確認各種連線問題造成的原因，首先 Ptt 站務總監 okcool 先在理論上較多針對 Ptt 的 App 開發者所在看板：<a href="https://www.ptt.cc/bbs/AppsForBBS/index.html">AppsForBBS 板</a>，籲請各 App 開發者在使用 websocket 連線登入時，配合加上 User-Agent 資訊，以方便統計各軟體使用 Websocket 的連線狀況。</p><p>至於其他連線方式(ssh, telnet)，根據既有的公開程式可以得知都會留下相關記錄，因此這方面就不再說明了。</p><h2 id="分析與討論">分析與討論</h2><p>另外在 Ptt、Ptt2 SYSOP 板爬梳一些討論資料，以及 <a href="https://github.com/ptt/pttbbs">PttBBS 原始碼</a>、<a href="https://www.ptt.cc/bbs/PttCurrent/">PttCurrent 板</a>提供的相關文件後，我們可以找到當初 PttBBS 可以承受同時間 15~6 萬人上線，關鍵在於 PttBBS 會經由 logind 程式接收大量 telnet 連線並為各 Client 顯示登入畫面，登入成功後再導入 mbbsd 進行主要的 bbs 指令操作。</p><p>然而，ssh 連線方式的實作則是直接在 Linux Server 開一個 <code>bbs</code> / <code>bbsu</code> 帳號，login shell 分別設爲 <code>/home/bbs/bin/bbsrf</code> 和 <code>/home/bbs/bin/utf8</code> ( symbolic link 到 <code>/home/bbs/bin/bbsrf</code> )，連線成功後即直接開啟 mbbsd 程式進行登入程序。</p><p>引用 BBS 開發者 <a href="https://github.com/IepIweidieng">IepIweidieng(github)</a> 在 <a href="https://discord.ccns.io">CCNS Discord</a> #bbs-dev 的<a href="https://discord.com/channels/330361502643257345/370600485612290060/843869940427522099">描述</a>:</p><blockquote><p><code>logind</code> 在使用者成功登入後才會將使用者的 <code>fd</code> 轉交給 <code>mbbsd</code> 並進行 <code>fork()</code>。<code>mbbsd</code> daemon 模式則是一連線就會 <code>fork()</code>。非 daemon 模式則是完全從頭啟動。</p></blockquote><p>而 PttBBS 傳統上給 ssh 連線用的就是 <code>mbbsd</code> 的非 daemon 模式，<code>fork()</code> 的工作則是交給 OpenSSH Server 的 <code>sshd</code> 來進行。</p><p><img src="https://i.imgur.com/P6w4fjq.png" alt=""></p><p>因此給 PttBBS 用的 <code>logind</code> 效能如何是 PttBBS 開發者可以研究如何改善的，但 OpenSSH Server 的效能調校能改的就相對有限了。</p><p>近年來加密連線防範封包側錄的資訊安全意識興起，ssh 連線被各使用者、手機 Apps 預設值，甚至是 BBS 爬蟲程式(如: <a href="https://github.com/PttCodingMan/PyPtt">PyPtt</a>) 大量採用，因此也開始被懷疑是影響 PttBBS 近年處理大量連線的效能瓶頸。</p><h2 id="嘗試方案-暫停-ssh-連線-觀察">嘗試方案: 暫停 ssh 連線 -&gt; 觀察</h2><p>今年 5 月，COVID-19 在臺灣的本土疫情爆發，因此 PttBBS 遇到的連線效能瓶頸也更加明顯，那段期間在每日 12pm 就會開始出現系統過載的畫面了，更別說是 2pm 召開防疫記者會的時候。那時候站方還有在 SYSOP 板發布<a href="https://www.ptt.cc/bbs/SYSOP/M.1621416649.A.5E7.html">公告</a>，籲請使用者盡量改用 Websocket 加密連線方式來代替。但這樣的籲請措施能做的還是有限，一來 Websocket for BBS 在終端機上還沒有一個相對方便的指令連線方案，另外就是會有使用者反應在尖峯時段用 ssh 連線「搶」進去的機率反而比較高。</p><p>另外在該期間，Ptt 也<a href="https://www.ptt.cc/bbs/PttNewhand/M.1621264236.A.23D.html">暫停</a>了 ssh 連線登入。我們目前認為是作為確認 ssh 造成連線壅塞原因的手段。</p><h2 id="站方解決方案：以-logind-為基礎重新實作-SSH-server">站方解決方案：以 logind 為基礎重新實作 SSH server</h2><p>今年 5/31，Ptt 系統站長 robertabcd 在 <a href="https://term.ptt2.cc">ptt2.cc</a> 發佈公告 ( <code>#1Wj4MGKt (SYSOP)</code> )，宣佈開始在 ptt2 測試新版 SSH。雖然該次以失敗(原因: 部分 client, 如 PuTTY, 登入畫面顯示仍有問題)，但也為 BBS 提供 SSH 連線兼顧效能的可行性，增添了不小的可能。</p><p>後來在 6/7，新版 SSH 再度上線(<code>#1WlJ2MXQ (SYSOP) [ptt2.cc]</code>)，這次使用者操作方面穩定性就提升了不少，也因此過了數天後就上線到 <a href="http://ptt.cc">ptt.cc</a>。這部分也可以從 <code>telnet</code> 或 <code>nc</code> 等工具程式針對 port 22 測試而得知。 (<code>telnet ptt.cc 22</code>)</p><p>以往會得到類似以下結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ telnet ptt.cc 22                                                                                        [17:37:31]</span><br><span class="line">Trying 140.112.172.2...</span><br><span class="line">Connected to ptt.cc.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">SSH-2.0-OpenSSH_8.4p1</span><br></pre></td></tr></table></figure><p>現在則是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ telnet ptt.cc 22                                                                                        [17:37:31]</span><br><span class="line">Trying 140.112.172.2...</span><br><span class="line">Connected to ptt.cc.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">SSH-2.0-bbs-sshd</span><br></pre></td></tr></table></figure><p>由於 OpenSSH 的版本號碼顯示只能在編譯階段修改，且新版 SSH server 版號顯示也拿掉了 OpenSSH 字樣，因此我們推測新版程式是利用 <a href="https://www.libssh.org/">libssh</a> 結合既有的 logind 提供服務，使透過 SSH 大量登入的連線可以順利交給 <code>logind</code> 處理，解決原本方法在這時產生的效能瓶頸。</p><p><img src="https://i.imgur.com/rphrOxQ.png" alt="7/3 當日使用者上線統計"><br><img src="https://i.imgur.com/6aPiuHM.png" alt="5/13 當日使用者上線統計"></p><p>目前從 <em>主選單 &gt; (X) &gt; (U) &gt; (Y) &gt; (U)</em> 進入昨日使用者統計來觀察 ptt 一天上線人次，已經不若以往每逢尖峰時間必過載的情形發生。但實際上而言能夠承受的密集大量登入程度為何，仍有待時間的考驗，以及是否有重大事件足以提供測試的契機了。</p><h2 id="結語">結語</h2><p>在有限的資源下維護開源專案都是不容易的，尤其因為 Ptt 的特殊性質，更難以導入用別人錢(贊助)就可以解決問題的方案。在這樣情況下還能有這樣進展，我們或許該充分體認到這類的事情都不是理所當然的。</p>]]></content:encoded>
      
      
      
      <category domain="https://blog.clam.ml/tags/opensource/">opensource</category>
      
      <category domain="https://blog.clam.ml/tags/foss/">foss</category>
      
      <category domain="https://blog.clam.ml/tags/ptt/">ptt</category>
      
      <category domain="https://blog.clam.ml/tags/ptt2/">ptt2</category>
      
      <category domain="https://blog.clam.ml/tags/bbs/">bbs</category>
      
      <category domain="https://blog.clam.ml/tags/maplebbs/">maplebbs</category>
      
      <category domain="https://blog.clam.ml/tags/openssh/">openssh</category>
      
      <category domain="https://blog.clam.ml/tags/libssh/">libssh</category>
      
      
      <comments>https://blog.clam.ml/2021/07/04/ptt-is-testing-new-sshd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PyGMT, 在 Python 製圖領域推廣 GMT 的利器? 我 ok, 你先用?</title>
      <link>https://blog.clam.ml/2021/06/21/pygmt-2021-6-feedback/</link>
      <guid>https://blog.clam.ml/2021/06/21/pygmt-2021-6-feedback/</guid>
      <pubDate>Sun, 20 Jun 2021 23:37:03 GMT</pubDate>
      
      <description>&lt;p&gt;Generic Mapping Tools，通用製圖工具，官方以及常見的簡稱為 GMT，是在地球科學領域廣泛使用的地理製圖工具之一。它可以在各種平臺結合 Shell Script (bash、csh)，Batch file(Windows) 的特性以及第三方工具(如: awk)，撰寫腳本以進行空間資訊的數據處理及高度客製化的地圖、圖表繪製。PyGMT 於 2020 年 5 月釋出，作為 GMT 在 Python 的 API。究竟這樣的專案對於 GMT 的使用族群而言有什麼可利用之處呢？以下分享個人的使用心得。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Generic Mapping Tools，通用製圖工具，官方以及常見的簡稱為 GMT，是在地球科學領域廣泛使用的地理製圖工具之一。它可以在各種平臺結合 Shell Script (bash、csh)，Batch file(Windows) 的特性以及第三方工具(如: awk)，撰寫腳本以進行空間資訊的數據處理及高度客製化的地圖、圖表繪製。PyGMT 於 2020 年 5 月釋出，作為 GMT 在 Python 的 API。究竟這樣的專案對於 GMT 的使用族群而言有什麼可利用之處呢？以下分享個人的使用心得。</p><span id="more"></span><h2 id="GMT-與-PyGMT-介紹">GMT 與 PyGMT 介紹</h2><p>Generic Mapping Tools，通用製圖工具，官方以及常見的簡稱為 GMT。於 1988 年釋出第一個 1.0 版本，並且受<a href="http://www.nsf.gov/">美國國家科學基金會 (NSF)</a>的贊助持續開發至今，在 2021 年 6 月 5 日已經釋出 6.2.0 版本，是在地球科學領域廣泛使用的地理製圖工具之一。它可以在各種平臺結合 Shell Script (bash、csh)，Batch file(Windows) 的特性以及第三方工具(如: awk)，撰寫腳本以進行空間資訊的數據處理及高度客製化的地圖、圖表繪製。</p><p>GMT 團隊在 5.x 版釋出時，就已經積極投入應用程式介面(API)的開發，並陸續開發了 Fortran，MATLAB/Octave，Julia 等語言的 API。GMT 6.x 於 2019 年釋出後，於隔年 5 月便有了 GMT 在 Python 的 API，被命名為 PyGMT 專案。讓使用者能夠利用 Python 語法呼叫 PyGMT 提供的函式透過 GMT 的官方 API (而非透過 Shell 呼叫)進行製圖腳本的撰寫。究竟這樣的專案對於 GMT 的使用族群而言有什麼可利用之處呢？以下分享個人的使用心得。</p><h2 id="PyGMT-潛在優勢">PyGMT 潛在優勢</h2><p>以下先分享使用 PyGMT 的好處：</p><ol><li>可以更輕鬆地結合在 Python 更為強大的套件(<code>pandas</code>，<code>numpy</code>，<code>obspy</code>)進行科學數據的運算與結果製圖</li><li>避開對系統 Shell 的直接呼叫，以提升以 GMT 為基礎建構應用程式的安全性。(相對於很多人偷懶直接使用 <code>system()</code> 直接呼叫 <code>gmt</code> 指令)</li><li>在 PyGMT 函數內的參數名稱，會設計成一般人較容易理解的長參數名稱，相較於 GMT 在 shell 指令的選項以短參數為主，可讀性大幅提升</li></ol><p>關於參數名稱的部分，這邊引用並微幅修改 <a href="https://gmt-tutorials.org/making_first_map.html">GMT 教學手冊</a> 的範例作為對照。</p><p>預計出來的原圖如下：<br><img src="https://gmt-tutorials.org/_images/making_first_map_gmt6_fig4.png" alt=""></p><p>若使用 GMT 5 的語法在 Shell 進行製圖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gmt pscoast \</span><br><span class="line">    -R19.42/22.95/59.71/60.56 \</span><br><span class="line">    -JM6i \</span><br><span class="line">    -W0.1p,black \</span><br><span class="line">    -Gdarkseagreen2 \</span><br><span class="line">    -Scornflowerblue \</span><br><span class="line">    -Df \</span><br><span class="line">    -P \</span><br><span class="line">    -Ba2f0.5g1 \</span><br><span class="line">    -BWSne+t<span class="string">&quot;Archipelago Sea&quot;</span> \</span><br><span class="line">    -A0.1 \</span><br><span class="line">    -U &gt; archi_sea.ps</span><br></pre></td></tr></table></figure><p>GMT 6 則是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gmt coast \</span><br><span class="line">    -R19.42/22.95/59.71/60.56 \</span><br><span class="line">    -JM6i \</span><br><span class="line">    -W0.1p,black \</span><br><span class="line">    -Gdarkseagreen2 \</span><br><span class="line">    -Scornflowerblue \</span><br><span class="line">    -Ba2f0.5g1 \</span><br><span class="line">    -BWSne+t<span class="string">&quot;Archipelago Sea&quot;</span> \</span><br><span class="line">    -A0.1 \</span><br><span class="line">    -U \</span><br><span class="line">    -png archi_sea</span><br></pre></td></tr></table></figure><p>而 PyGMT 則是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pygmt</span><br><span class="line">fig = pygmt.Figure()</span><br><span class="line">fig.coast(</span><br><span class="line">        region=[19.42, 22.95, 59.71, 60.56],</span><br><span class="line">        projection=&quot;M6i&quot;,</span><br><span class="line">        shorelines=[&#x27;0.1p&#x27;, &#x27;black&#x27;],</span><br><span class="line">        land=&#x27;darkseagreen2&#x27;,</span><br><span class="line">        water=&#x27;cornflowerblue&#x27;,</span><br><span class="line">        frame=[&#x27;a2f0.5g1&#x27;, &#x27;WSne+t&quot;Archipelago Sea&quot;&#x27;],</span><br><span class="line">        area_thresh=0.1,</span><br><span class="line">        timestamp=True,</span><br><span class="line">)</span><br><span class="line">fig.show()</span><br><span class="line">fig.savefig(&#x27;archi_sea_pygmt.png&#x27;)</span><br></pre></td></tr></table></figure><p>在查看文件之前，哪個腳本較能夠讓人直覺去猜到各參數的意義，相信答案已經很明顯了吧。</p><h2 id="PyGMT-的疑慮與待改進之處">PyGMT 的疑慮與待改進之處</h2><p>然而，相對於 GMT 的開發歷史，PyGMT 仍然是一個非常非常年輕的套件。縱使有了 NSF 的贊助，相對於其他類似規模的開源專案資源開發能量仍然十分有限。也因此我們可以輕易地找出許多理由，去建議剛接觸指令製圖的新手「先不要」輕易嘗試 PyGMT 這個套件。理由如下：</p><ol><li>PyGMT 支援的 GMT 模組數量仍然有限</li><li>即使某些 GMT 模組能被 PyGMT 支援，但能使用的長選項參數、能夠讀取的資料格式仍相對受限</li><li>開發/教學文件與範本數量仍極度缺乏，但此部分至少可以對照 GMT 指令版本的文件</li></ol><p>第 1,2 點的部分，以目前釋出的 0.3.1 版為例，該版本不支援、支援有限但常被使用的 GMT 指令模組包含了 <a href="https://docs.generic-mapping-tools.org/6.2/project.html"><code>project</code></a> (對平面直線附近包含深度資訊的座標點進行剖面繪製)，<a href="https://docs.generic-mapping-tools.org/6.2/supplements/seis/pssac.html"><code>pssac</code></a> (讀取 SAC 檔並繪製地震波形)， <a href="https://docs.generic-mapping-tools.org/6.2/histogram.html"><code>histogram</code></a> (繪製長條圖，目前已於 <a href="https://zh.wikipedia.org/zh-tw/Git">git</a> <code>master</code> 開發中版本開始支援)，<a href="https://docs.generic-mapping-tools.org/6.2/supplements/seis/meca.html"><code>meca</code></a> (舊稱 <code>psmeca</code>，已實作，但不支援震源機制球置放在震央以外的位置)…等。</p><p>即使 <code>pssac</code> 和 <code>histogram</code> 功能可分別用 <code>obspy</code> 和 <code>matplotlib</code> 替代，但使用介面上的差異，進而造成腳本轉換所要花費的時間，卻遠大於從 GMT 5,6 轉換到其他 PyGMT 支援的模組所要付出的。</p><p>另外在傳統 GMT 繪圖的過程中，我們需要 <code>-V</code> 選項來讓程式輸出更多明顯的提示訊息以利除錯校正，在 PyGMT 中開發者嘗試使用 <code>verbose=True</code> 使其參數更容易被理解，但大量使用此選項後便會發現許多函式仍然只能使用 <code>V=True</code> 來應付其 alias 無法實作的問題。</p><p>上面所遇到的問題會徒然花費使用者時間去想辦法應付這些問題，進而大幅降低使用者嘗試的意願。包含並不限於使用替代套件、透過 <code>pygmt.clib.Session.call_module()</code> 呼叫 API、回去使用 <code>subprocess</code>…等，其中必須用到 <code>subprocess()</code> 及其 pipe 功能來應付模組 <code>project</code> 不被 PyGMT 支援的問題時，已經開始思考當初使用這個套件的理由了。</p><h2 id="PyGMT-還有搞頭嗎">PyGMT 還有搞頭嗎?</h2><p>身為開源軟體的使用者、推廣者而言，仍然希望這個專案的開發能夠繼續下去。畢竟上面實際使用該套件後遇到的問題，多偏向開發、使用者社群尚未完整地建立起來的因素，再加上一般使用者多偏向從現有/舊有腳本去修改來繪製研究成果以節省時間，這也成為了推廣新工具(PyGMT，GMT 6 語法)、給予回饋的巨大阻礙。然而新需求、新方法總會不斷地出現，停留在舊版程式與腳本也遲早會遇到無法被新平臺、新工具支援的問題。如果我們持續停留在消耗別人既有成果而對於回饋開源專案這件事情不甚重視的話，未來能從它身上滿足的需求也將持續受限，無法跨出新的一步。</p><p>其他能做的事情，或許可以列舉：</p><ul><li>整理以上支援受限的 module 資訊，包含其必要性 (是否優於替代方案)，回報給開發者社群。</li><li>瞭解該專案 alias 實作方式，將能夠理解且需要修改的部分整理成新的 Pull Request (當然開發者搶先一步修好是更值得慶幸的)。</li><li>整理分享更多樣的繪圖腳本紀錄供社群參考，以利讓更多人在有意願嘗試時有個參考依據。</li></ul><p>對於那些前仆後繼在 GMT 相關專案投入大量心力改善軟體品質的前輩，個人也給予深深的尊敬與肯定，自己能做的除了以上那些，可能也只有幫忙打包新版的程式到自己習慣用的 Linux 發行版(Archlinux Arch Users Repository)，方便別人嘗鮮吧。</p>]]></content:encoded>
      
      
      
      <category domain="https://blog.clam.ml/tags/opensource/">opensource</category>
      
      <category domain="https://blog.clam.ml/tags/genericmappingtools/">genericmappingtools</category>
      
      <category domain="https://blog.clam.ml/tags/geophysics/">geophysics</category>
      
      <category domain="https://blog.clam.ml/tags/earthscience/">earthscience</category>
      
      <category domain="https://blog.clam.ml/tags/mapping/">mapping</category>
      
      <category domain="https://blog.clam.ml/tags/python/">python</category>
      
      <category domain="https://blog.clam.ml/tags/freesoftware/">freesoftware</category>
      
      
      <comments>https://blog.clam.ml/2021/06/21/pygmt-2021-6-feedback/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在 Debian/Ubuntu 等 Linux 發行版下簡易打包軟體 – 以 SAC 為例</title>
      <link>https://blog.clam.ml/2021/06/06/sac-debian-packaging/</link>
      <guid>https://blog.clam.ml/2021/06/06/sac-debian-packaging/</guid>
      <pubDate>Sat, 05 Jun 2021 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;我們常見到的Linux 發行版基本上就是一個「拼裝車」，組合各個不同來源的專案原始碼組合成一個有多用途的「通用作業系統」。我們將以地震學軟體 SAC 為例，說明如何簡單利用「套件打包」的機制，藉由既有軟體打包管理工具，使得發行版內的軟體更能有秩序地被管理。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>我們常見到的Linux 發行版基本上就是一個「拼裝車」，組合各個不同來源的專案原始碼組合成一個有多用途的「通用作業系統」。我們將以地震學軟體 SAC 為例，說明如何簡單利用「套件打包」的機制，藉由既有軟體打包管理工具，使得發行版內的軟體更能有秩序地被管理。</p><span id="more"></span><h2 id="套件打包的目的">套件打包的目的</h2><p>相對於 Windows、FreeBSD 作業系統都有官方維護的基礎元件(base component)，我們常見到的 Linux 發行版基本上就是一個全然的「拼裝車」，組合各個不同來源的專案原始碼組合成一個有實際用途的「<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F#%E9%80%9A%E7%94%A8%E4%B8%8E%E4%B8%93%E7%94%A8%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F">通用作業系統</a>」。通常發行版的維護者會優先將符合<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%8A%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BD%AF%E4%BB%B6">自由及開放原始碼授權</a>的專案納入其關鍵元件，各個發行版看似五花八門，但終究離不開這個本質。少數發行版(如: Ubuntu Linux)在法律資源充足下會在安裝期間提供授權不相容(如: Nvidia 驅動、OpenZFS 核心模組)的元件以增進使用者體驗。但在大部分情況下，只要是授權有疑慮或明定不開放散佈原始碼的軟體，在發行版整合上就是一個巨大的阻礙，因為這意味者我們無法透過社群合作的機制，讓更熟悉軟體開發部署工程的人檢視我們平常使用的程式是否是易於使用、沒有潛在問題的。</p><p>而我們在 Unix-like (Linux、FreeBSD、Solaris、更早期的 SunOS…等) 環境下，最早期藉由原始碼安裝軟體方式，就是進入原始碼資料夾。執行 <code>make</code> 將軟體編譯完成後，再使用 root 權限 <code>make install</code>，將軟體安裝到預設的路徑 ( <code>/usr/local</code> ) 下。但現在我們已經極度不建議安裝用這樣的方式在預設路徑( <code>/usr/local</code> )，因為容易跟其他也手動安裝在同位置的套件混淆，使得嘗試解除安裝的過程中容易誤刪手動 <code>make install</code> 安裝其他套件的檔案，讓升級或解除安裝套件更加複雜。更別說在「不重複安裝」的前提下，解決 A 函式庫一更新，以它為基礎的 B 專案就得重新編譯才能找到 A 以執行的常見問題了。</p><p>因此我們開始使用了「套件打包」的機制，藉由單一專案的軟體打包管理程式(dpkg, rpm)，統一發行版內軟體管理的秩序。</p><h2 id="使用情境-–-為什麼要「打包」SAC">使用情境 – 為什麼要「打包」SAC?</h2><p>SAC 全名是 Seismic Analysis Code，是個歷史悠久的地震學資料處理軟體，由美國的 IRIS (地震學研究機構聯合會) 團隊開發，主要使用 C 語言開發，需在相容 Unix-like (如 Linux, FreeBSD, Cygwin…等) 的 X 視窗系統下才能正常使用，並只提供相關原始碼、執行檔給非特殊國家之地震學相關人員。若需取得相關程式需至官方網站<a href="https://ds.iris.edu/ds/nodes/dmc/forms/sac/">填寫申請表單</a>，由該單位人員審核後才可藉由 email 附件取得檔案。</p><p>傳統而言，在同一作業系統環境下安裝 SAC 有兩種途徑，第一種是直接把 IRIS 提供的執行檔手動放到指定位置 ( Linux 下指定 <code>/usr/local</code> ) 後執行，第二種是在作業系統下自行使用 gcc 等編譯器建置後安裝到自行指定的位置 (若未指定則仍安裝到 <code>/usr/local</code> )</p><p>第一種方法的方便之處在於說，不需要瞭解太多 Linux / Unix 的基礎知識與相關操作就可以藉由非常基本的指令 (cp, sudo…等) 完成安裝</p><p>缺點在於只能安裝在 <a href="https://zh.wikipedia.org/zh-tw/X86">x86</a>/<a href="https://zh.wikipedia.org/zh-tw/X86-64">x86_64</a> 平臺下的 CPU 才能順利執行的 Linux 執行檔，也就是說若你今天想在同樣安裝 Linux 的小型開發板 (如：樹梅派、Apple Silicon M1 上執行的虛擬機器)或是在官方沒考慮的 Unix-like 環境(Cygwin, FreeBSD, Termux)下執行是做不到的 (樹梅派或許可以在上面開 QEMU 模擬，但速度可預想是非常非常慢的)</p><p>另外第一種方法也無法自行客製化相關功能，這限制的問題在於說用此方法安裝的 SAC 程式只能在極度有限的操作體驗下進行，而使得剛熟悉 bash 等指令介面的使用者進入 SAC 的指令介面會發現 TAB 自動補完、上下、結束時保留指令歷史、Ctrl+R 搜尋歷史等在 bash 有的功能這邊都沒有或限制更多。但如果客製化編譯就可以藉由增加相關選項就可以改善。</p><p>因此我們知道如果藉由第二種方法有可修改安裝路徑、自行增減相關功能、移植更方便等優勢，但此方法對於沒有接觸過系統管理、程式開發的使用者挑戰並不小，且若想要提供給多個各自符合資格的人員，安裝一樣客製化設定同時符合易於安裝、升級、解除安裝原則的 SAC 程式也勢必會花費很多心力。此時發行版下的套件管理工具就是我們很重要的夥伴了! 在這邊我們將用 Debian/Ubuntu 下的 <code>apt</code> (<code>dpkg</code>) 工具來協助我們更輕易地部署「我們的 SAC」</p><h2 id="SAC-Debian-Ubuntu-Packager-介紹">SAC Debian/Ubuntu Packager 介紹</h2><p><img src="https://github.com/sean0921/sean0921.github.io/raw/3ef1e32d61fc62c546c6ba31ef526ccc050cc7b2/images/demo.gif" alt=""></p><p>這個工具使用最基本的 Shell Script 腳本，搭配 <code>dpkg</code> 程式，將編譯後的 SAC 程式放置在特定資料夾後，再加入軟體資訊後打包壓縮成單一安裝檔 (<code>&lt;pkg_name&gt;.deb</code>)，最後再由使用者從 <code>apt</code> 程式安裝該套件，納入發行版套件管理系統的記錄中。</p><p>由以上討論我們可以歸納這個方法的好處：</p><ol><li>使得 SAC 更易於安裝、解除安裝、升級</li><li>SAC 底層用到的函式庫一旦有重大升級，發行版套件管理程式（<code>apt</code>）會跳出相關警告，讓你記得要重新安裝程式。</li><li>減少繁瑣的環境變數設定</li></ol><p>使用這個工具安裝 SAC 之前，符合相關資格的使用者仍需自行至 IRIS 網站申請下載原始碼，以遵守授權相關規範。詳細安裝方式請參考 <a href="https://github.com/sean0921/sac_debian_packager">GitHub</a> 上的 README 頁面。</p><h2 id="結論">結論</h2><p>套件打包適合用在一定數量的人會安裝的軟體上，以減少繁瑣安裝過程中可能會出錯的機率，以增進效率並兼顧使用體驗。也是讓 Linux 在有限硬碟空間下提供完整功能的關鍵。若有心在未來的專案上利用 Linux 環境作為開發測試平臺，這仍然是不可或缺的知識。</p>]]></content:encoded>
      
      
      
      <category domain="https://blog.clam.ml/tags/packaging/">packaging</category>
      
      <category domain="https://blog.clam.ml/tags/linux/">linux</category>
      
      <category domain="https://blog.clam.ml/tags/sysadmin/">sysadmin</category>
      
      <category domain="https://blog.clam.ml/tags/seismology/">seismology</category>
      
      
      <comments>https://blog.clam.ml/2021/06/06/sac-debian-packaging/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
